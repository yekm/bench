{"name":"Bench","tagline":"Algorithms benchmarking \"framework\"","body":"[![Build Status](https://drone.io/github.com/yekm/bench/status.png)](https://drone.io/github.com/yekm/bench/latest)\r\n\r\n### Description\r\nSimple benchmarking program with fancy graphs. It measures the time which was\r\ntaken to process some (varying) amount of data by the algorithm. Then it just\r\nplots the relationship between time and amount of processed data.\r\n\r\nThis project is written for (self)educational purposes and fun. Some things\r\nmay look a bit awkward.\r\n\r\n### Sample graphs\r\nhttp://yekm.name/bench/d3 or http://yekm.name/bench/aws-g2.2xlarge/\r\n\r\nHave a look at this beautiful example:\r\n![](https://s3-eu-west-1.amazonaws.com/yekm/2014-08-26-195453_1920x1080_scrot.png)\r\nThis plot shows relationship between \"randomness\" of data and time taken to sort that data.\r\nSo on X axis we have the (rough) number of random shuffles in pre-sorted array of 1 000 000 integers.\r\nWhat we can say from this example?\r\n* When array is almost sorted _Insertion sort_ is the fastest. It becames slower than _Timsort_ with 16 shuffles in array.\r\n* With 256 shuffles _Timsort_ becomes slower than _Introsort_ (default std::sort in stl), and then quickly becomes 1.5 times slower than _Introsort_.\r\n* _Merge sort_ behaves quite independently on randomnes. Only when array is almost completely random it becomes ~3 times slower. And only ~2 times slower than _Introsort_.\r\n* Sorting with the GPU (CUDA thrust library) is independent on array randomness. It is always blazing fast.\r\n\r\n### Usage\r\n#### Compilation:\r\n```\r\ngit submodule update --init\r\nmkdir build\r\ncd build\r\ncmake ..\r\nmake\r\n```\r\n#### Running:\r\nMake separate folder and run bench from where\r\n```mkdir tmp && cd tmp```\r\n\r\nListing all tasks and algorithms\r\n```\r\n$ ../bench -l\r\nTask 0: popcnt perfomance\r\n  32bit SWAR popcnt\r\n  Brian Kernighan popcnt\r\n  Simple popcnt\r\n  generalized 32 bit SWAR popcnt\r\n  generalized 64 bit SWAR popcnt\r\n  intrinsics _mm_popcnt_u64 manual asm popcnt\r\n  intrinsics _mm_popcnt_u64 popcnt\r\n  intrinsics _mm_popcnt_u64 unrolled popcnt\r\n  table lookup popcnt\r\n  thrust popcnt\r\nTask 1: sorting algorithms\r\n  Insertion sort n^2\r\n  Introsort std::sort n*log(n)\r\n  Merge sort n*log(n)\r\n  Selection sort n^2\r\n  Shell sort n*log^2(n)\r\n  swenson binary insertion sort n^2\r\n  swenson grail sort\r\n  swenson heapsort n*log(n)\r\n  swenson mergesort n*log(n)\r\n  swenson quiksort n*log(n)\r\n  swenson selection sort n^2\r\n  swenson sell sort n*log^2(n)\r\n  swenson sqrt sort\r\n  swenson timsort n*log(n)\r\n  thrust::sort\r\nTask 2: Sorting algorithms, partially sorted data, 1000000 elements\r\n  Insertion sort n^2\r\n  Introsort std::sort n*log(n)\r\n  Merge sort n*log(n)\r\n  Shell sort n*log^2(n)\r\n  swenson timsort n*log(n)\r\n  thrust::sort\r\nTask 3: 1000000 vector lengths\r\n  handmade unrolling\r\n  loop unrolling\r\n  template unrolling\r\n```\r\n\r\nQuick run\r\n```\r\n$ ../bench -t 0.1\r\n```\r\n\r\nSkip some tasks. However final listing will include this skipped tasks and old\r\nmeasured perfomance data will be preserved between runs.\r\n```\r\n$ ../bench -t 1 -s 2\r\n```\r\n\r\nEach algorithm runs `a` (by default 3) times with same data to minimize the error.\r\nIt is possible to regenerate data and run algorithm `a` times again. The number\r\nof iterations of data regeneration specified by `-b`\r\n```\r\n$ ../bench -t 1 -s 0,2 -a 2 -b 3\r\n```\r\n\r\n#### Viewing results:\r\nFor now it is quiet uncomfortable. You need a web server and a couple of links.\r\n```\r\n$ ln -s ../../html/d3/main.js main.js\r\n$ ln -s ../../html/d3/main.css main.css\r\n$ ln -s ../../html/d3/index.html index.html\r\n$ python3 -m http.server 8082\r\n$ $BROWSER http://localhost:8082\r\n```\r\n\r\n### Adding algorithms for benchmarking\r\nAdding algorithms for benchmarking is easy (at least I've tried to make it easy).\r\n\r\nDecide what type of data your algorithm should process. Derive a class from `GenericData<T>`\r\nor use already made `common::RandomData` and others. `GenericData<T>` has two useful functions\r\n`T & get_mutable()` and `const T & get_const()`.\r\nIf algorithm is not modifying it should ask for const data. In this case next algorithm\r\nwill get just the same data. Otherwise modified data discarded and new data\r\ngenerated (which _should_ be exactly the same as previous, but it can depend on actual\r\nimplementation).\r\n\r\nDerive from `Task` and implement `prepare_data(size_t n)`. Here you create and return\r\nyour data of size n. For example:\r\n```\r\nreturn std::make_shared<common::RandomData<int>>(n);\r\n```\r\n\r\n`RandomData<T>` derived from `GenericData<std::vector<T>>`, so `get_mutable()` will\r\nreturn `std::vector<T>&`.\r\n\r\nAmount of data will be doubled on each run of algorithm. Testing will\r\nbe stopped then execution time exeeds 60 sec (by default) or amount of data\r\nexceeds memory capacity (std::bad_alloc thrown). Timeout can be changed by\r\ncommand line arguments. Data growth can be changed by reimplementing virtual\r\nfunction `Task::get_n()`.\r\n\r\nDerive from `Algorithm` and implement `do_run(TaskData & td, std::unique_ptr<AResult> &)`.\r\nHere you cast passed `TaskData` to `GenericData<T>` which you pick earlier and do some\r\nprocessing. Running time of this function is measured. For example, in case of `RandomData<int>`:\r\n```\r\nstd::vector<int> &d = static_cast<GenericData<std::vector<int>>&>(td).get_mutable();\r\nstd::sort(d.begin(), d.end());\r\n```\r\n\r\nWrite a cpp file in which make a static struct. In constructor you should create\r\nTask and all Algorithms. Add Algorithms to Task and add Task to TaskCollection.\r\nSince your struct is static and TaskCollection is a singleton all algorithms and tasks\r\nwill be created and registered in TaskCollection automatically at program launch.\r\nAnd thus there is no need to make any changes in present code. Just create a subfolder\r\nin tasks/, place you code there and re-run cmake.\r\n\r\nAdd your cpp file in `tasks/CMakeLists.txt`.\r\n\r\nQuiet messy description. You should look at actual code, it is simple <s>and clear</s>.\r\n\r\n### LICENSE\r\nMIT.\r\n","google":"UA-57427066-1","note":"Don't delete this file! It's used internally to help with page regeneration."}